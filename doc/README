        Реализация поиска по регулярному выражению.

        Основные функции.
        1) int parse_rexpr_object(rexpr_object * parent, const char * opt, ssize_t start, ssize_t * end)
        2) int check_str_rexpr_object(rexpr_object * parent, const char * str, ssize_t start, ssize_t * end)
        3) void free_rexpr_objects(rexpr_object * parent)
        
        1) Парсит строку с регулярным выражением. Создает представление выражения в структурах.
        rexpr_object * parent           Основная структура, перед передачей ее в функцию необходимо установить тип 
                                        'rexpr_object_type_start_main'. Пример показан в функции rexpr_find(...).
        const char * opt                Указатель на строку с регулярным выражением.
        ssize_t start                   Позиция первого символа в строке opt.
        ssize_t * end                   Позиция последнего символа в строке opt.
        Возвращает 0 в случае успешного завершения, -1 в случае ошибки.
        
        2) Проверяет совпадение строки с регулярным выражением. НЕ ИЩЕТ подстроку в строке.
        rexpr_object * parent           Основная структура с регулярным выражением.
        const char * str                Указатель на строку.
        ssize_t start                   Позиция первого символа в строке str.
        ssize_t * end                   Позиция последнего символа в строке str.
        Возвращает одино из трех значений:
                rexpr_check_status_SUCCESS      Совпадение найдено. В переменную *end помещается позиция последнего символа
                                                совпавшей подстроки.
                rexpr_check_status_UNSUCCESS    Совпадение не найдено. Переменная *end не изменяется.
                rexpr_check_status_END_OF_LINE  Совпадение не найдено, т.к. строка закончилась. Переменная *end не изменяется.
        
        3) Освобождает память от данных регулярного выражения.
        
В функции ssize_t rexpr_find(const char * str, ssize_t str_len, const char * opt, ssize_t opt_len, ssize_t * end_substr)
реализован пример использования (1), (2) и (3) для поиска подстроки в строке по регулярному выражению.
В main.c реализованы два примера, для поиска всех совпадений в строке либо в файле.

        Правила для регулярных выражений, актуальные для текущей версии.
Управляющие символы:
        .       Один любой символ.
        *       Повторение 0 или более раз.
        +       Повторение 1 или более раз.
        ()      Объединение правил.
        []      Один любой символ из набора.
        
Дополнительные символы:
        \       Начало escape-последовательности.
        n       Перенос строки. Только с символом \ для набора [].
        t       Табуляция. Только с символом \ для набора [].
        ^       Логическое отрицание - NOT. Только с объединением правил ().
        |       Логическое ИЛИ - OR. Только с объединением правил ().
        
Правила:
        STRING          Набор любых символов, кроме управляющих.
                        Например: 
                                'hello' будет искать целое слово "hello"
                                'hi all' будет искать целое слово "hi all"
                                'abw(c' - ошибка, т.к. '(' управляющий символ.
                        При этом правила вида 'abcdfg' и 'abc(dfg)' логически эквивалентны, но в первом случае будет поиск
                                слова "abcdfg", а во втором случае сначала поиск слова "abc", а затем слова "dfg".
        DOT             '.' один любой символ.
                        Например:
                                '.a' найдет в строке "abwgdabvag": "da", "va".
        STAR            '*' повторение 0 или более раз. Используется в паре с любым другим правилом, кроме PLUS и STAR.
                        Примеры:
                                'a*', '(abw)*', '[abw]*', '.*' и т.д.
                                'ab*' найдет в строке "abvabbva": "ab", "abb", "a".
        PLUS            '+' повторение 1 или более раз. Тоже самое, что и STAR.
        ROUND_BRACKETS  '()' объединение правил. Объеденяет в себе ЛЮБЫЕ правила.
                        Также можно использовать '^' либо '|'.
                        Пример:
                                '^(abc)', '|((abc)(ab)(ccc))', '(^(a)|((as)ds))'
                                Такое объединение '(abc(abc)a*)' в правилах имеет вид ( STRING ROUND_BRACKETS STAR )
                        Логическое отрицание '^()' означает, что все результаты в рамках этого объединения будут обращены.
                        Это означает, что любое совпадение с любым правилом в этом объединеении вернет несовпадение.
                        Логическое ИЛИ '|()' означает, что при совпадении с любым правилом в этом объединеении вернется совпадение.
                        Т.е. достаточно одного совпадения в объединении для получения положительного результата.
        SQUARE_BRACKETS '[]' набор символов. При совпадении с одним из символов или диапазонов вернет совпадение.
                        Например: '[abc]', '[a-b]'
                        Cимвол '[' необходимо ставить только к открывающей скобке, т.е. '[[]' либо '[[abc]'.
                        Для символа ']' позиция значения не имеет.
                        Можно использовать для добавления в правила управляющих символов, например: 
                                '(array[[].*[]])', 'main[(].*[)]' и т.п.
                        Для добавления символа переноса строки или табуляции используются escape-символы:
                                '[\n\t]', '[abc \n]+' и т.п.