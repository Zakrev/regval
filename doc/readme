Пример
Дано регулярное выражение
        ((a*b+)+c*)*
Дана строка
        abcaacbcaabcacssgh1

1. Анализ выражение и создание структур
Начинается проход с конца строки, т.е. "((a*b+)+c*)*" <--, первый символ '*'. Идентифицируется как группа, создается структура.
Далее символ ')', тоже создается как группа. Далее '*'. Получаем 'c', распознается как текст, группа '*' закрывается. И т.д.
Полученная структура:
'*'
 |
'()'
 |
'+'     -> '*'
 |          |
'()'       'c'
 |
'*' -> '+'
 |      |
'a'    'b'
        Примечание 0:
        Структуры добавляются по типу "первым пришел, последним вышел". 
        Чтобы в итоге сохранить порядок, как при чтении --> "((a*b+)+c*)*"
        Примечание 1:
        Выражение "a|b|c" создаст одну группу типа "ИЛИ"
                        '|'
                         |
                        'a' -> 'b' -> 'c'
        Примечание 2:
        Выражение [a-c] преобразуется в выражение "a|b|c", [a-b1-2] -> "a|b|1|2"
        Примечание 3:
        Возможно преобразование [a-c] будет таким
                '[]'
                 |
                'range a-c'
        для [qa-b!1-2] таким
                '[]'
                 |
                'q' -> 'range a-b' -> '!' -> 'range 1-2'
        где 'range' это проверка, относится ли символ к области, т.е.
                'range a-z' эквивалентна if( 'a' < .. < 'z')
2. Поиск совпадений.
P - позиция первого символа найденой подстроки
S - размер найденой подстроки
        Читаем первый символ:
        a\bcaacbcaabcacssgh1
        Запоминаем его место P=0
        Заходим в первую группу в списке, это '*', заходим в первую группу этой группы '()' и так далее, пока не дойдем до символа 'a'.
        Получаем такой путь:
        '*' -> '()' -> '+' -> '()' -> '*' -> 'a'
        Сравниваем символы. 'a' == 'a' остаемся в этой группе. Увеличиваем длину S=1
        Читаем 'b'.
        Сравниваем 'b' != 'a'. Выходим на уровень выше.
        '*' -> '()' -> '+' -> '()' -> '*'
        Идем к следующей группе. Полный путь
        '*' -> '()' -> '+' -> '()' -> '+' -> 'b'
                Примечание:
                        Т.к '*' и '+' подразумевают повторения символов и групп, то при переходе к следующей структуре 
                        нужно поступать следующим образом:
                        1) при входе в группу ('*' или '+') запоминаем состояние S0=S
                        2) после получения команды перейти к следующей структуре,
                           проверяем: если эта группа содержит только символ
                                '*'
                                 |
                                'a'
                           то переходим к следующей структуре;
                           если эта группа содержит группу
                                '*'
                                 |
                                '()'
                           то сравниваем состояния: если S0 == S, то переходим к следующей структуре;
                           если S0 < S, то повторяем проверки в этой группе.
        Сравниваем 'b' == 'b' остаемся в этой группе. Увеличиваем длину S=2
        Читаем 'c'.
        Сравниваем 'c' != 'b'. Выходим из группы.
        '*' -> '()' -> '+' -> '()' -> '*'
                Примечание 0:
                У группы '+' должен быть флаг выполнения спец. условия. Если хотя бы один символ не попал в эту группу,
                то отправляем в группу выше оповещение о неудачном совпадении.
                В данном случае, такое оповещение актуально только для '()'. При его получении состояние возвращается к
                тому, в котором проверка была при входе в эту группу, т.е. S=S0, и происходит выход 
                (без оставшихся проверок) на уровень вверх.
                Примечание 1:
                Вместо флага.
                При входе в группу '+' запоминаем состояние S1=S.
                Если нужно сделать переход из группы в следующую, проверяем состояние если S1 == S, 
                то отправляем в группу выше оповещение о неудачном совпадении. Если S1 > S, то все хорошо, продолжаем.
        Далее групп нет, выходим.
        '*' -> '()' -> '+' -> '()'
        Выходим.
        '*' -> '()' -> '+'
        Переходим к следующей. Полный путь
        '*' -> '()' -> '*' -> 'c'
        Сравниваем 'c' == 'c' остаемся в этой группе. Увеличиваем длину S=3.
        Читаем 'a'.
        Сравниваем 'a' != 'c'. Выходим из группы. Так-как это последняя, выходим к началу '*'.
        И так далее.
